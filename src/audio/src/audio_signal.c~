/* Copyright (C) 2015, Redbeard Enterprises Ltd.
 *
 * Not to be used without express written consent.
 * All rights reserved.
 */

#include <math.h>

#include "he_return.h"
#include "he_memory.h"

#include "red_audio.h"
#include "_red_audio.h"

int
redAudioSignalContextCreate(
    RedAudioSignalContext* asCtx,
    size_t     channel_count,
    red_u32    sample_rate,
    red_u32    sample_format,
    red_u32    frame_format,
    red_u32    signal_type,
    float      frequency,
    float      amplitude,
    RedContext rCtx
    )
{
  int rc = RED_SUCCESS;

  if (!asCtx)
    return RED_ERR_NULL_POINTER;
  if (*asCtx)
    return RED_ERR_INITIALIZED_POINTER;

  /* by design, each of these flags should be a single bit,
     and fall within their designated mask */
  if (!(   POWER_OF_TWO(sample_format)
        && POWER_OF_TWO(frame_format)
	&& POWER_OF_TWO(signal_type)   
        && POWER_OF_TWO(sample_format & RED_AUDIO_SAMPLE_FORMAT_MASK)
	&& POWER_OF_TWO(frame_format & RED_AUDIO_FRAME_FORMAT_MASK)
	&& POWER_OF_TWO(signal_type & RED_AUDIO_SIGNAL_MASK))
     ) {
    rc = RED_ERR_INVALID_ARGUMENT;
    goto end;
  }

  /* TODO: validate sample rate */

  /* TODO: this is likely too simple of a check */
  if (channel_count < 0 || channel_count > 8) {
    rc = RED_ERR_INVALID_ARGUMENT;
    goto end;
  }

  rc = redMalloc( rCtx, (void**)asCtx, sizeof(**asCtx) );
  if (rc) goto end;

  (*asCtx)->format        = sample_format | frame_format | signal_type;
  (*asCtx)->sample_rate   = sample_rate;
  (*asCtx)->channel_count = channel_count;
  (*asCtx)->frequency     = frequency;
  (*asCtx)->amplitude     = amplitude;
  (*asCtx)->time_offset   = 0.0;
  (*asCtx)->rCtx          = rCtx;

 end:
  if (rc && *asCtx)
    redFree( rCtx, (void**)asCtx, 0 );

  return rc;
}

int
redAudioSignalContextDestroy(
    RedAudioSignalContext* asCtx
    )
{
  if (!asCtx)
    return RED_ERR_NULL_POINTER;

  if (*asCtx)
    return redFree( (*asCtx)->rCtx, (void**)asCtx, 0 );

  return RED_SUCCESS;
}


static
float
rfSineSignalSample(
    float frequency,
    float time
    )
{
  return sin( 2 * M_PI * frequency * time );
}
/*   */

typedef float (*redfuncSignal)(float, float);

int
redAudioSignalConjureFrame(
    void*                 signal_frame,
    size_t                sample_count,
    RedAudioSignalContext asCtx
    )
{
  int rc = RED_SUCCESS;

  int i = 0;

  /* this convention turned into an unfortunately ambiguous name */
  redfuncSignal rfSignal = NULL;

switch(asCtx->format & RED_AUDIO_SIGNAL_MASK) {
 case RED_AUDIO_SIGNAL_SINE:
   rfSignal
}
return RED_SUCCESS;
  
}


/*

gotos - i use them to fall through on error, and code allocs to
        magically free themselves if badness occurs


*/
